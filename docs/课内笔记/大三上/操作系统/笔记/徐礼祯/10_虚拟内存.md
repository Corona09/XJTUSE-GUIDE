[TOC]

# 10 虚拟内存（Virtual Memory）

## 10.1 Background

基本要求: 进程必须全部放入内存后方可运行

如果进程大于内存容量或者内存中同时运行多个进程, 则需要动态加载、覆盖等技术.

如果无法从物理上扩充内存, 则可以考虑从逻辑上扩充内存.

常规存储器的特征:

- **一次性**: 作业在运行前需要一次性的全部装载入内存;
- **驻留性**: 作业装入到内存后便会一直留在内存中, 直到作业结束.

正因为一次性与驻留性, 使得程序中暂时不用的数据占用了大量的内存空间, 从而使作业无法装入内存.

**程序的局部性原理**:
在一段时间内, 程序的执行仅局限于某个部分; 相应地, 它所访问的存储空间也局限于某个区域内.

时间局部性:

- 如果程序中的某条指令一旦执行, 则不久的将来该指令可能再次被执行;
- 如果某个存储单元被访问, 则不久以后该存储单元可能再次被访问.
- 产生时间局部性的典型原因是\*\*在程序中存在着大量的循环操作.

空间局部性

- 一旦程序访问了某个存储单元, 则在不久的将来, 其附近的存储单元也可能被访问. 即程序在一段时间内所访问的地址可能集中在一定的范围内
- 典型原因: 程序是**顺序执行**的.

虚拟内存是一种允许进程部分装入内存就可以执行的技术.

虚拟存储建立在离散分配的存储管理基础上.

虚拟内存能通过一下方式实现:

- 请求页式

- 请求段式

### 虚拟存储的特征

- **离散性**: 在内存分配时采用离散的分配方式，是虚拟存储器的最基本的特征。

- **多次性**: 一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。是虚拟存储器最重要的特征。

- **对换性**: 作业运行过程中信息在内存和外存的对换区之间换进、换出。

- **虚拟性**: 从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。

### 引入虚拟内存的好处

- 可在较小的可用内存中执行较大的用户程序;
- 可在内存中容纳更多的程序并发执行;
- 简化了编程操作, 不影响编程时的程序结构（与覆盖技术比较）;
- 提供给用户可用的虚拟内存空间通常大于物理内存.

## 10.2 请求页式 Demand Paging

在基本分页基础上增加了请求调页和页面置换功能后形成的页式虚拟存储系统.

### 实现虚拟存储要解决的问题

- 程序部分可以运行吗？
  - 取页: 将所需要的部分装入内存;
- 发现程序不再内存时, 如何将其装入后继续运行？
  - 请求调页: 缺页时, 产生缺页中断, 将外存上的页调入内存;
- 内存无空间时怎么办？
  - 页面置换(Replacement): 内存不足时, 将哪些页换出内存（置换 not 交换）

## 10.3 页面调入策略

调入策略(Fetch Policy)

1. 预调页(Prepaging): 程序第一次进内存时;
2. 请求调页(Demand Paging)

为使进程运行, 实现需要将一部分要执行的程序和数据调入内存.

**预调页策略**

- 主动的页面调入策略, 即把那些预计很快会被访问的程序或数据所在页面预先调入内存;

- 预测准确率不高(50%), 主要用于进程的首次调入, 也有的系统将预调页策略用于请求调页.

**请求调页策略**

- 当进程在运行中发生缺页时, 由系统将缺页调入内存, 目前虚拟存储器系统大多采用此策略

- 在调页时须花费较大的系统开销, 如需要频繁启动磁盘I/O.

**从何处调入页面**

- 在虚拟存储系统中, 外存被分成两部分: 文件区和对换区. 对换区(连续分配)的磁盘I/O速度比文件区(离散分配)要高.
  - 从文件系统中调入页面
  - 从交换区中调入页面

### 请求调页

只有在一个页需要的时候才把它换入内存

- 需要很少的 I/O
- 需要很少的内存
- 快速响应
- 支持多用户

#### 请求调页中的硬件支持

1. 请求分页的页表机制
   
   它是在纯分页的页表机制上形成的，由于只将应用程序的一部分调入内存，还有一部分仍在磁盘上，故需在页表中再增加若干项，供程序(数据)在换进、换出时参考。在请求分页系统中的每个页表项如图所示。
   
   <center><img title="" src="file:///home/corona/Documents/study/notes/OS/.img/10-请求分页系统中的页表项.png" alt=""></center>
   
   页表中存储的信息:
   
   - **状态位 P**: 也称**存在位**用于指示该页是否已调入内存，供程序访问时参考。
   
   - **访问字段 A**: 用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考
   
   - **修改位 M**: 只有被修改过才有必要重新写回外存以保证一致性;
   
   - **外存地址**: 用于指出该页在外存上的地址，通常是物理块号，供调入该页时使用。

2. 缺页中断:
   在请求分页系统中, 每当所要访问的页面不在内存时, 便产生一缺页中断, 请求 OS 将所缺页调入内存, 与一般中断区别在于:
   
   - 缺页中断在指令执行期间产生和处理中断信号, 而一般中断在一条指令执行完后检查和处理中断信号;
   
   - 缺页中断返回到该指令的开始重新执行该指令, 而一般中断返回到该指令的下一条指令执行.
   
   - **一条指令在执行期间可能产生多次缺页中断**.

3. 地址变换机构
   请求分页系统中的地址变换机构，是在分页系统的地址变换机构的基础上，再为实现虚拟存储器而增加了某些功能所形成的，如**产生和处理缺页中断**，以及**从内存中换出一页的功能**等等，下图给出了请求分页系统的地址变换过程。
   
   ![](/home/corona/Documents/study/notes/OS/.img/10-请求分页系统的地址变换过程.png)
   
   步骤
   
   1. 查找页表来确定此次地址访问是否合法;
   
   2. 如果不合法, 则终止该进程, 否则如果有效但不在内存中, 即发生了缺页, 则需要将其调入内存
   
   3. 从外存中找到所需要的页;
   
   4. 找到一个空闲物理帧, 启动磁盘, 将该页读入内存;
   
   5. 读磁盘结束后, 修改页表以指出该页已在内存中;
   
   6. 重新开始执行刚才发生缺页中断的指令, 这是它才可以访问刚才调入的页.

总结:

1. 处理缺页中断;
2. 从磁盘读入所需的页（主要耗时）;
3. 重新开始被中断的进程

缺页率:
...

## 请求调页的性能

发生缺页时会导致以下步骤的发生

- 陷入OS;

- 保存该用户寄存器和进程状态;

- 确定该中断是一个缺页中断;

- 检查该页面引用是合法的并确定该页在磁盘上的位置;

- 将该页从磁盘读入一个空闲物理帧.
  
  - 在磁盘等待队列中等待直到该请求被处理
  
  - 等待设备寻道延迟
  
  - 将该块从磁盘传送至内存

以上步骤并不是在任何情况下都会发生的, 这里的主要操作是:

- 处理缺页中断

- 从磁盘读入所需的页

- 重新开始被中断的进程

其中最大的一部分时间开销为**从磁盘读入所需的页**.

### 缺页率

假定作业$J_i$共有$m$页, 系统分配给它的主存块为$n$块, 这里$m>n$。
如果作业$J_i$执行过程中总的内存访问次数为$A$, 成功访问的次数为$S$, 不成功的访问次数为$F$(产生缺页中断的次数), 则:

$$
A = S + F\\
缺页率\;p = \cfrac{F}{A}
$$

## 10.3 页面置换算法

在进程运行过程中, 如果发生缺页, 而内存中有无空闲块, 此时需要将内存中的某一页调换到磁盘的对换区.

不好的算法可能导致进程“抖动”.

理论上讲应将那些以后不再被访问的页面换出, 或把那些在较长时间内不会再被访问的页面换出.

### 10.3.1 最佳算法（OPT）

被置换的页将是**之后最长时间不被使用的页.**

很难实现的啦～

### 10.3.2 先进先出（FIFO）

FIFO 会产生 Belady异常: 更多的帧反而导致缺页率增加.

### 10.3.3 最近最久未使用 (Least Recently Used, LRU)

选择最长时间没有使用的页进行替换.

### 10.3.4 LRU 近似算法

**这部分记得比较混乱, 见课本P278**

## 10.4 页帧分配

如何给进程分配一定的空间？
进程能拿到多大空间取决于内存多大,最少取决于计算机的体系结构.需要分配能够正常执行的大小.

主要分配策略:

- 平均
  
  如果有100页和5个进程, 则给每个进程分配20页.

- 按比例
  
  根据每个进程大小分配

- 按优先级
  
  如果进程$P_i$产生一个缺页, 从一个较低优先级的进程中选择一页来替换.

**有空闲帧时可以从空闲帧链表中选择一个帧分配，当没有空闲帧可用时，从哪里分配帧？**

- 全局替换: 进程在所有的页中选择一个替换页面；一个进程可以从另一个进程中获得页面;

- 局部替换: 每个进程只从属于它自己的页中选择.

局部置换时，分配给每个进程的帧的数量不变
全局置换时，进程的帧数量会增加，但是无法控制页错误率
相对而言，**全局替换会带来较高的系统吞吐率**

- 固定分配 & 局部置换
  
  - 基于进程的类型（交互型或批处理型等），或根据程序员、系统管理员的建议，为每个进程**分配固定数目的物理块**，在整个运行期间都不再改变;
  
  - 如果进程在运行中发生缺页，只能从该进程已在内存的页面中选一页换出，然后再调入另一页，保证分配给该进程的内存空间不变

- 可变分配 & 全局置换
  
  - 系统为每个进程分配一定数目的物理块，OS本身也保持一个空闲物理块队列
  
  - 当某进程发生缺页时，系统从空闲物理块队列中，取出一物理块分配给该进程，并将欲调入的缺页装入其中。
  
  - 当空闲物理块队列中的物理块用完时，OS才从内存中选择一页调出，该页可能是任一进程的页。

- 可变分配&局部置换：
  
  - 根据进程的类型或程序员的要求，为每个进程分配一定数目的内存空间，并且在进程运行期间可根据情况（缺页率）适当增加或减少所分配的物理块数
  
  - 当某进程发生缺页时，只允许从该进程已在内存的页面中选出一页换出，而不影响其它进程的运行

## 10.5 抖动 Thrashing

如果进程分配到的帧数量小于计算机体系结构所要求的最小数量, 那么必须暂停进行执行, 并将其置换出去, 使其所有分配帧空闲.

频繁换页称为颠簸, 又叫抖动.

### 为什么有抖动

$$
\sum \mathrm{locality} > \mathrm{Total\;Memory\;Size}
$$

### 解决方式

- 挂起一些进程, 降低多道程序的道.

- 增加页的大小(而不是更大的页表)

- 增大物理内存的大小

- 预调页

局部性原理:
给每个进程分配的最小物理块数不能少于 locality 大小.

### 工作集理论

- 根据局部性原理, 进程在一段时间内总是集中访问一些页面

- 如果分配给一个进程的物理块数太少了，使该进程的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生缺页

- 如果能为进程提供与活跃页面数相等的物理块数，则可减少缺页中断次数

#### 工作窗口

**工作窗口**($\Delta$)是指定对于给定的访问序列选取定长的区间, 落在工作窗口中的页面集合成为工作集.

#### 具体实现

OS 跟踪每个进程的工作集, 并为其分配大于其工作集的物理块数. 如果还有空闲物理块, 则可启动另外的进程. 如果所有进程的工作集之和超过了可用物理块的总数, 则 OS 会选择暂停一个进程, 该进程被换出, 所释放的物理块可分配给其他进程

如何跟踪工作集合？

- 定时器中断和引用位

### 控制缺页频率(Page-Fault Frequency)

- 如果缺页率太低, 回收一些页框;

- 如果缺页率太高, 为一些进程分配一些页.

### 预调页

- 预测哪些页面会用到, 事先调入;

分页大小

- Page size selection（页面尺寸选择）
- Fragmentation（碎片）页面大, 则内碎片大
- table size （表大小）页面小, 则页表占用的空间大
- I/O overhead（I/O 开销）磁盘 I/O 时间中传输时间和数据量有关系, 但它占的比例很小, 而寻道时间和旋转延迟时间占了很大的比例.所以页面尺寸比较大会有利于减少磁盘 I/O 时间.
- 减少 I/O 及内存的占用: 要求页面尺寸小 , 采用小页, 总的 I/O 就会降低, 因为小页能够更精确的匹配局部
- 减少缺页率: 要求页面尺寸大
- 总的趋势: 页面尺寸越来越大, 这是由于 CPU 速度和内存容量的增长超过了磁盘速度的加快

TLB
TLB 命中率
TLB 范围
通过 TLB 可以访问的内存量, 等于 TLB 的个数与页大小的乘积
增加 TLB 范围
增加页大小
或者提供多种页大小 TLB 命中率
TLB 范围
通过 TLB 可以访问的内存量, 等于 TLB 的个数与页大小的乘积
增加 TLB 范围
增加页大小
或者提供多种页大小

I/O 互锁
I/O 互锁
在请求页面调度时, 允许某些页锁在内存中
当用户内存有 I/O 操作时

不对用户内存进行 I/O, 通过系统内存进行
允许页锁在内存中

内存映射文件
