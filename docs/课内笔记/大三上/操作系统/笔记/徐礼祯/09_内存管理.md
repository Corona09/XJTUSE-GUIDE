<center><font size="10"> 9 内存管理</font></center>

# 1. Background

程序必须放入内存才能执行.

地址转换的时间: 

- 编译时: 编译时就知道程序要放在哪儿;
- 装入程序时: 一旦装入内存, 不能再更换;
- 运行程序时: 需要硬件对地址映射的支持.

# 2. 逻辑与物理地址空间

逻辑地址: 由CPU产生, 也叫做虚拟地址;

物理地址: 内存设备所读入的地址.

在编译时期、装入时期的地址绑定策略生成的逻辑与物理地址是相同的, 运行时绑定策略不一样.

## 2.1 地址重定位

> **地址重定位**: 将程序装入到与其地址空间不一致的物理空间, 所引起的一系列地址变换过程.

### 2.1.1 静态重定位

在装入一个作业时, 把作业中的指令地址全部转换为绝对地址, 在作业执行过程中就无须在进行地址转换;

### 2.1.2 动态重定位

动态地址重定位是在程序执行过程中, 在CPU访问内存之前, 将要访问的程序或数据地址转换成内存地址.

动态重定位依靠硬件地址变换机构完成.

## 2.2 内存管理单元 (Memory Management Unit, MMU)

把虚拟地址映射到物理地址的硬件.

在MMU策略中, 基址寄存器中的值在其被送入内存时被加入到用户进程所产生的每个地址中.

用户程序所对应的是逻辑地址, 物理地址是不可见的.

早期的内存很小, 因此产生了一些技术: 

## 2.3 动态加载技术 Dynamic Loading

例程在调用之前不加载.将程序分为模块, 需要时再加载相应模块.

不需要OS的支持, 需要程序员设计实现.

## 2.4 动态链接技术 Dynamic Linking

链接被推迟到执行时期.

在用到的模块的位置用一小段代码（存根）定位, 用来定位合适的保留在内存中的库程序.

## 2.5 覆盖 Overlays

只是在内存中保留那些在特定时间所需要的指令和数据

当进程比所分配的内存大时, 覆盖是必需的.

由用户执行, 不需要操作系统的特别支持, 覆盖结构的程序设计很复杂.

要求用户清楚地了解程序的结构, 并指定各程序段调入内存的先后次序, 它是一种早期的主存扩充的方式


## 2.6 交换

一个进程可以暂时被交换到内存外的一个备份区, 随后可以被换回内存继续执行.

备份区—是一个固定的足够大的可以容纳所有用户内存映像的拷贝;可以提供对这些内存映像的直接存取.

由操作系统控制, 利用外存空间（进程交换区）, 通过对进程实体的整体交换, 来满足用户进程的内存需要.

它的主要特点是**打破了进程运行的驻留性**.


- 动态重定位帮顶方式才能换入/换出不用在同一内存地址;
- I/O操作时不允许换入/换出, 需要锁定在内存 or 通过OS: I/O不直接将结果返给进程而是给OS,由OS给进程.

---

## 2.7 存储管理方式

**连续分配方式**: 为一个程序分配一段连续的内存空间, 主要有: 

- 单一连续区管理方式;
- 多分区管理方式, 是一种可用于多道程序的较简单的存储管理方式, 又分为:
  - 固定分区方式
  - 可变分区方式

# 3. 连续分配

主存被分为两部分: 系统/用户

单道: 用户去只能容纳一道作业

基址寄存器策略由来保护用户进程（同其他进程和改变的操作系统代码和数据分开）

基址寄存器包含最小物理地址的值;限长寄存器包含逻辑地址的范围, 每个逻辑地址必需比限长寄存器的值小.

多道时: 

固定/动态分区分配

## 3.1 固定分区

固定式分区是在作业装入之前, 内存就被划分成若干个固定大小的连续分区.
划分工作可以由系统管理员完成, 也可以由操作系统实现.

一旦划分完成, 在系统运行期间不再重新划分, 即分区的个数不可变, 分区的大小不可变, 所以, 固定式分区又称为静态分区.
划分分区的方法如下: 

- 分区大小相等: 只适用于多个相同程序的并发执行（处理多个类型相同的对象）, 缺乏灵活性（进程大小不是相等的, 8M空间2M程序6M空间不能用, 称为**内碎片**）.
- 分区大小不等: 多个小分区、适量的中等分区、少量的大分区.根据程序的大小, 分配当前空闲的、适当大小的分区（小进程放小分区, 大进程放大分区, 尽量减少内碎片）.

一般将内存的用户区域划分成大小不等的分区, 可适应不同大小的作业的需要  

系统有一张**分区说明表**, 每个表目说明一个分区的大小、起始地址和是否已分配的使用标志

优点: 开销小, 易于实现

缺点: 

- 分区大小固定: 内碎片
- 分区总数固定: 限制并发执行的程序数目

采用的数据结构: 分区表－－记录分区的大小和使用情况



## 3.2 多分区分配

分区的划分是动态的, 不是事先确定的.

分区——可用的内存快, 不同大小的分区分布在整个内存中.

当一个进程到来的时候, 他将从一个足够容纳它的分区中分配内存.

会产生外碎片——可能有很多不连续的外碎片.

**分区分配算法**: 寻找某个空闲分区, 其大小需大于或等于程序的要求.若是大于要求, 则将该分区分割成两个分区, 其中一个分区为要求的大小并标记为“占用”, 而另一个分区为余下部分并标记为“空闲”.分区的先后次序通常是从内存低端到高端.

**分区释放算法**: 需要将相邻的空闲分区合并成一个空闲分区.(这时要解决的问题是: 合并条件的判断)



怎样从一个空的分区列表中满足一个申请需要？

**首先适应**

分配最先找到的合适的分区.

特点: 

...

**最佳适配**

搜索整个序列, 找到条件适合的最小的分区进行分配.

**最差适应**

搜索整个序列, 寻找最大的分区进行分配.

在速度和存储的使用上, 首先适应与最佳适应比最差适应好.

解决外碎片

**紧凑**: 即向一个方向移动已分配的作业, 使那些零散的小空闲区在另一方向连成一片.

内存中的进程需要移动, 成本大.

# 4. 分页 Paging

将进程分为等大小的块, 称为**页**（page）, 将内存分为等大小的块, 称为**帧**（frame）.
页与帧是等大小的.


动态分区产生外碎片的原因是要求把作业安置在一连续存储区内.

分页存储管理是解决存储碎片的一种方法, 要避开连续性的要求, 允许进程的物理地址空间不连续.

通过页表来对应页与物理帧.

解决了外碎片, 但是仍可能有内碎片（最后一页）, 因为进程大小可能并不是页大小的整数倍.

用户是不感知分页的过程的, 分页过程由硬件进行.

页的大小通常取$2^n$

逻辑地址由硬件分为两部分: 页号与页内偏移.页号即第几页, 页内偏移及页内的第几个地址.
高位是页号, 低位是页内偏移.

页表存放在内存中.
页表基址寄存器指向页表
页表限长寄存器表明页表的长度

在这个机制中, 内一次的数据/指令存取需要两次内存存取, 一次是存取页表, 一次是存取数据.

解决方法: 
通过一个联想寄存器（也有叫TLB的）, 可以解决两次存取的问题.

命中率: 在联想寄存器中找到页号的比率, 比率与联想寄存器的大小有关.

## 内存保护
内存的保护由每个页框项链的保护位来执行.

---

需要减少页表所占的空间
- 两级页表: 把页表再分页, 建立页表的页表.  
  逻辑地址分为三部分: P1,P2,d, 外部页表, 内部页表, 页内偏移.  
  增加了内存访问次数, 带来了性能上的下降.  
  最大极限: 7级页表.  

- 哈希页表  
  可能产生哈希值的碰撞, 使用链表的解决方法.  
  链表是一个三元组: (q,s,x),q是页号, s是物理帧号, x是链表中的序号

- 反转表  
  对整个系统的内存空间构建一张页表.  
  有多少物理帧, 就有多少个页表的项.  
  表项中存储: 物理帧对应的逻辑页, 一个二元组, (pid,p), 即“哪个进程的哪个页”.  
  减少了内存占用, 但是查找时间长.  
  反转表不能实现进程对页的共享.

---

**页的共享**

共享代码（Shared Code）

分页的特点
- 没有外碎片, 每个内碎片不超过页大小
- 一个程序不必连续存放
- 程序全部装入内存

# 5. 分段 Segmentation

支持用户观点的内存管理方式.
一个程序是一些段的集合, 一个段是一个逻辑单位.
以段为单位将其放入内存.

一种动态重定位.

通过**段表**实现段与内存的对应.
段表存储段的起始地址(base)与长度(limit).

段表放在内存里, 有段表的基址寄存器和段长寄存器.

没有内碎片, 但会产生外碎片. 

### 分段的特点: 
- 没有内碎片, 外碎片可以通过内存紧缩来...


### 分段和分页的比较

# 6. 段页式 Segmentation with Paging

将整个主存分成大小相等的物理块（帧）.

将用户程序先分段, 为每一段赋予一个段名并对每一段进行分页, 以页为单位进行离散地分配.

地址结构由段号(S)、段内页号(P)和页内偏移组成(W).

逻辑地址到物理地址的映射:   
段表+页表

段表中存储段号、页表长度、页表起始.

页表中仍存储页号页与帧号的对应关系.

在段页式中, 为了获取一条指令或数据, 需要访问三次内存.
