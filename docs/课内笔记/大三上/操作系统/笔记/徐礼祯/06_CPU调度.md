<center>
<font size='10'>CPU 调度</font>
</center>

# 1. 基本概念

## 1.1 三级调度

- 高级(Long-term)调度——作业调度
  决定把外存输入井上处于作业后备队列上的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后再将新创建的进程排在就绪队列上，准备执行。
- 低级(Short-term)调度——进程调度
  决定就绪队列中哪个进程将获得处理机，然后由分派程序执行把处理机分配给该进程的操作。
- 中级(Medium-term)调度——对换

通过多道程序设计得到 CPU 的最高利用率
CPU-I/O 脉冲周期 - 进程的执行包括进程在 CPU 上执行和等待 I/O
进程的执行以 CPU 脉冲开始,其后跟着 I/O 脉冲.进程的执行就是在这两个状态之间进行转换。

**CPU 脉冲的分布,在系统中,存在许多短 CPU 脉冲,只有少量的长 CPU 脉冲**。

当 CPU 空闲时，OS 就选择内存中的某个就绪进程，并给其分配 CPU

## 1.2 什么时候需要 CPU 调度

1. **运行转等待**
2. _运行转就绪_
3. _等待转就绪_
4. **终止运行**

1 4 非抢占式调度：

其他被称为 抢占式调度

### 1.2.1 非抢占方式

把处理机分配给某进程后，便让其一直执行，直到该进程完成或发生某事件而被阻塞时，才把处理机分配给其它进程，不允许其他进程抢占已经分配出去的处理机。

- 优点:实现简单、系统开销小，适用于大多数批处理系统环境
- 缺点:难以满足紧急任务的要求，不适用于实时、分时系统要求

### 1.2.2 抢占方式

允许调度程序根据某个原则，去停止某个正在执行的进程，将处理机重新分配给另一个进程

### 1.2.3 抢占的原则

- **时间片原则**:各进程按时间片运行，当一个时间片用完后，便仃止该进程的执行而重新进行调度。这个原则适用于分时系统。
- **优先权原则**:通常对一些重要的和紧急的进程赋予较高的优先权。当这种进程进入就绪队列时，如果其优先权比正在执行的进程优先权高，便中止正在执行的进程，将处理机分配给优先权高的进程，使之执行
- **短作业优先原则**:当新到达的作业比正在执行的作业明显短时，将暂停当前长作业的执行，将处理机分配给新到的短作业，使之执行。

## 1.3 Dispatcher

分派程序负责将对 CPU 的控制权交给短调度选择进程，包括：

- 切换上下文
- 切换到用户态
- 跳转到用户程序的适当位置并重新运行

分派延迟：分派程序终止一个程序运行并启动另一个程序所需的延迟。

# 2. 调度准则

**CPU 利用率**：使 CPU 尽量忙碌；

**吞吐量**：单位时间内运行完的进程数；

**周转时间**：进程从提交到结束的全部时间；

**等待时间**：进程在就绪队列中等待调度的时间片总和；

**响应时间**：从进程提出请求到首次被响应的时间段[在分时系统环境下不是输出完结果的时间]

**调度算法影响的是等待时间**。

# 3. 调度算法

## 3.1 先来先服务（FCFS）

字面意思不解释

可以用作作业调度（by 到达作业队列的先后），也可用作进程调度（by 到达就绪队列的先后）

有利于长作业，不利于短作业；

有利于 CPU 繁忙型，不利于 I/O 繁忙型。

## 3.2 短作业优先（Shortest Job First, SJF）

关联到每个进程下次运行的 CPU 长度, 调度 CPU 长度最短的进程。

**最短的平均等待时间**。

需要判断下一个 CPU Burst 长度：

其长度只能估计，可以通过先前的 CPU 脉冲长度及计算指数均值进行

**采用 SJF 有利于系统减少平均周转时间，提高系统吞吐量**。

一般情况下 SJF 调度算法比 FCFS 调度算法的效率要高一些, 但实现相对要困难些。
如果作业的到来顺序及运行时间不合适，会出现饥饿现象，例如，系统中有一个运行时间很长的作业 JN，和几个运行时间小的作业，然后，不断地有运行时间小于 JN 的作业的到来，这样，作业 JN 就因得不到调度而饿死。另外，作业运行的估计时间也有问题。

## 3.3 优先级调度(Priority Scheduling)

分为**抢占式**于**非抢占式**

短作业调度是 PS 的一个特例

需要确定进程的优先级

### 3.3.1 静态优先级

**静态优先级**在进程创建时确定，且在整个生命期中保持不变。

- 进程类型，通常系统进程的优先权高于一般用户进程的优先权。在用户进程中，I/O 繁忙的进程应优先于 CPU 繁忙的进程，以保证 CPU 和 I/O 设备之间的并行操作。
- 进程对资源的需求，如进程执行时间及内存需要少的进程应赋予较高的优先权；
- 根据用户要求，由用户的紧迫程度及用户所付费用的多少来确定进程的优先权。
- 在分时系统中，前台进程应优先于后台进程

静态优先级可能出现饥饿问题。

解决方法：**老化**——根据进程等待时间延长提高其优先级

### 3.3.2 动态优先级

**动态优先级**是指优先级随进程的推进而改变，改变优先级的因素有：

- 进程的等待时间
- 已使用处理机的时间
- 资源使用情况

## 3.4 Round Robin (RR)

每个进程将得到小单位的 CPU 时间[时间片]，通常为 10-100 毫 秒。时间片用完后，该进程将被抢占并插入就绪队列末尾

优点：响应时间较短

一般来说，RR 的平均周转时间比 SJF 长，但响应时间要短一些。

一组进程的平均周转时间并不一定随着时间片的增大而降低。一般来说，如果大多数（80%）进程能在一个时间片内完成，就会改善平均周转时间。

## 3.5 多级队列（Multilevel Queue）

按进程的属性来分类，如进程的类型、优先权、占用内存多少。。。

就绪队列分为：

- 前台队列：交互性要好，可以采用 RR 等
- 后台队列：可以采用另一种调度算法

调度须在队列间进行

进程一旦进入队列中，不会更换队列。可能产生饥饿。

## 3.6 多级反馈

存在多个就绪队列，具有不同优先级，各自按时间片轮转法调度。
允许进程在队列间移动。
各个就绪队列中时间片的大小各不相同，**优先级越高的队列时间片越小**。
当一个进程执行完一个完整的时间片后被抢占处理器，**被抢占的进程优先级降低一级而进入下级就绪队列**，如此继续，直至降到进程的基本优先级。而一个进程从阻塞态变为就绪态时要提高优先级；
最后会将 I/O 型和交互式进程留在较高优先级队列。

进程能在不同的队列间移动，可实现老化。

多级反馈队列调度程序由以下参数定义:

- 队列数
- 每一队列的调度算法
- 决定进程升级的方法
- 决定进程降级的方法
- 决定需要服务的进程将进入哪个队列的方法

## 3.7 高响应比优先

因为 SJF 中长作业运行得不到保证，因此引入动态优先权

定义高响应比（RP 值）：

$$
RP=\cfrac{已等待时间+要求运行时间}{要求运行时间}=1+\cfrac{已等待时间}{要求运行时间}


$$

HRRN 算法实际上是 FCFS 算法和 SJF 算法的折衷

优点：

- 等待时间相同，则 SJF；
- 要求的服务时间相同，则 FCFS；

长作业的优先级随着等待时间的增加而提高，不会出现得不到响应的情况。

- 缺点:
  作业调度程序要统计作业的等待时间，作浮点运算（这是系统程序最忌讳的）浪费大量的计算时间

# 4. 多处理器调度

负载均衡——设置一个公共的就绪队列。

对称多处理器——每个处理器决定自己的调度方案，每个 cpu 自己到公共就绪队列去取进程运行。必须确保 CPU 对就绪队列的访问是互斥的。

非对称多处理器——当进程在 CPU 间迁移时，其 CACHE 内容也必须迁移，代价很高

处理器亲和：进程一直在同一个 CPU 上运行

- 软亲和：试图使进程在一个 CPU 上运行，但不阻止；

- 硬亲和：不允许在 CPU 间迁移

实时调度是为了完成实时处理而分配处理器的调度方法。

系统要实现基于优先级的调度，实时进程必须具有最高优先级，且不能随着时间的推移降低优先级；调度延迟必须很小

为降低分派延迟，需要允许系统调用被抢占；

- 在长系统调用中插入抢占点：由于抢占点数量有限，因此效果并不是很好；
- 使整个内核可被抢占，但所有内核数据结构必须通过各种同步机制加以保护。

较高优先级进程需读或修改正在被另一个低优先级进程所访问的内核数据,高优先级进程需要等待低优先级进程的完成.这种现象称为优先级倒置。

优先级倒置产生的原因：？？？

优先级继承：(正在访问高优先级进程所需资源的)低优先级进程继承高优先级,直到相关资源处理完毕,它们的优先级再返回原来的值。
