# 复习总结

## 01 绪论

### 操作系统的发展与类型

1. 手工操作
2. 单道批处理(Simple Batch Processing)
3. 多道批处理系统(Multiprogrammed Batch System)
   运行特征:
- 多道性;
- 无序性;
- 调度性
4. 分时操作系统;
- 实时操作系统
- 并行系统
  - 对称多处理器
  - 非对称多处理器
- 分布式系统
- 网络操作系统
- 嵌入式操作系统
- 个人计算机系统

### 操作系统的功能

1. 处理机管理;
2. 存储管理;
3. 设备管理;
4. 文件管理;
5. 用户接口.

### 现代 OS 的特征

1. 并发;
2. 共享;
3. 虚拟;
4. 异步性

## 02 计算机系统结构

### 中断机制

#### 中断的分类

- 硬件中断(Hardware Interupt)
- 软件中断(Software Interupt, Trap)

#### 中断的作用

- 使系统更有效率,响应更快(more responsive)
- 现代操作系统是**中断驱动**的
- 中断将控制权转移到中断服务程序

#### 中断向量

中断向量是中断服务程序的入口地址

### 存储结构

<img src="./.img/存储结构.png"/>

### 硬件保护

**两状态操作 Dual-Mode Operation**

1. 用户态
2. 管态(或称 特权模式/系统模式) - 代表操作系统执行

模式位(mode bit)添加到计算机硬件，表示当前模式

系统引导时，硬件处于管态，在用户模式下执行用户进程;一开机的时候处于管态，要执行用户程序的时候转换为用户态;当出现中断或者陷阱时，硬件会切换到管态

特权指令: 只能在管态下运行的指令, 通常使用才做系统调用

例如: 设置定时器的值, 清除内存, 关闭中断.

非特权指令: 读时钟, 从用户态切换为管态

**I/O 保护**
所有的 I/O 操作都是特权指令, 用户不能直接进行 I/O 操作, 必须通过系统调用.

确保用户程序不能在管态下控制计算机.

**内存保护**
必须保护中断向量与中断服务程序

确定进程能访问的合法空间

- 基址寄存器(base register): holds the smallest legal physical memory address
- 界限寄存器(limit register): contains the size of the range.

用户态下生成的每个地址都要经过硬件检查.

**CPU 保护**
OS 需要防止用户程序陷入死循环或者不调用系统服务且不将控制权返回到 OS.

timer 定时器– interrupts computer after specified period to ensure operating system maintains control

## 04 进程(Process)

### 顺序执行与并发执行的特征

**顺序执行的特征**

- **顺序性**:按照程序结构所制定的次序执行;
- **封闭性**:独占全部资源,计算机的状态只由该程序的控制逻辑所决定;
- **可再现性**:初始条件相同则结果相同.

**并发执行的特征**

- **间断性(异步性)**
- **失去封闭性**
- **失去可再现性**

### 什么是进程?

为了描述程序在并发执行时对系统资源的共享,我们需要一个描述程序执行时动态特征的概念,这就是进程.

进程是执行中的程序.

### 一个进程包括什么

- PC(程序计数器)
- 栈(Stack)
- 数据(Data)

### 进程与程序的对应关系

通过多次执行,一个程序可以对应多个进程; 通过调用关系, 一个进程可以包括多个程序.

### 进程的特征

- **结构特征**: 进程实体 = 程序段 + 相关数据 + PCB;
- **动态**性: 进程的实质是进程实体的一次执行过程，因此动态性是进程的最基本特征
- **并发**性: 多个进程实体同存在于内存中，且能在同一段时间内同时运行，是最重要的特征
- **独立**性: 指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位
- **异步**性: 进程按各自独立的、不可预知的速度向前推进

### 进程的类型

- 系统进程
- 用户进程

系统进程与用户进程的区别?

### 进程状态

- 新建;
- 就绪;
- 运行;
- 等待;
- 终止.

<center>
<img src="./.img/process_state.png"/>
</center>

EXP1: 一个进程等待的 I/O 操作完成后, 进程状态将会从阻塞变为就绪.

EXP2: 在单处理器系统中,如果同时存在 10 个进程, 则处于就绪队列中的最多有 9 个(至少有一个处于运行状态).

### 进程控制块

PCB 是一个专门的数据结构, 系统用它来记录进程的外部特征, 描述进程的运动变化过程.

<center>
<img src="./.img/pcb_structure.png"/>
</center>

在创建进程时, 建立 PCB, 并伴随进程运行的全过程, 直到进程撤销.

进程与 PCB 是一一对应的.

PCB 经常被系统访问, 因此 PCB 应该常驻内存.

### 进程调度

#### 进程调度队列

- **作业队列**(Job Queue): 系统中所有进程的集合;
- **就绪队列**(Ready Queue): 在主存中, 就绪并等待执行的所有进程的集合;
- **设备队列**(Device Quque): 等待某一 I/O 设备的进程队列.

### 调度

- 长程调度
  - 选择可以进入**就绪队列**的进程,又称作业调度;
  - 控制了多道程序的道
- 短程调度
  - 选择可被下一个执行并分配的 CPU 进程
  - 切换频率高
- 中程调度
  为了缓和内存紧张的情况，将内存中处于阻塞状态的进程切换至外存上(挂起)，降低多道程度的度.当这些程序重新具备运行条件时，再从外存上调入内存.

EXP1: 短程调度是指从作业队列中选择作业并调入内存.

### 进程创建

进程何时创建?

- 作业调度: 批处理系统中，作业调度程序调度到某个作业以后，就把这个作业装入内存，并分配必要的资源,创建进程，插入就绪队列.
- 用户登录: 在分时系统中，用户在终端键入登录命令后，若是合法用户，系统建立一个进程，并插入就绪队列.

父进程可以创建子进程, 形成一棵进程树.

**资源共享**

- 父子进程共享所有资源;
- 子进程共享父进程资源的子集;
- 父子进程无资源共享.

**进程创建过程**

1. 申请空白 PCB;
2. 为新建立的进程分配资源;
3. 初始化程序控制块;
4. 将新进程插入就绪队列.

### 进程终止

### 进程阻塞

### 进程唤醒

### 协同进程

与其他进程共享数据的进程是协同进程.

独立进程不会影响另一个进程的执行或被另一个进程执行影响

协同进程可能影响另一个进程的执行或被另一个进程执行影响

协同进程的优点:

- 信息共享
- 加速运算
- 模块化
- 方便

### 进程间通信(IPC)

这一部分记得比较混乱, 详细见**_课本 P83_**.

#### 共享存储

- 使用共享存储模型的进程间通信要建立共享存储区;
- 进程通过读写共享存储区来交换信息;
- 由通信进程来确定交换的数据和位置，不受操作系统的控制.

**缓冲**

- 零容量: 发送者必须等待接收者;
- 有界容量: n 个消息有限长度, 连接满了发送者必须等待;
- 无界容量: 发送者从不等待.

#### 消息传递

用于进程传递的机制, 同步其间的活动;

消息系统————进程间通信无须再利用共享变量;

IPC 提供两个操作:

- `send`: 发送消息
- `receive`: 接收消息

### 直接通信与间接通信

#### 直接通信

进程必须显式命名

灵活性差

#### 间接通信

消息导向至信箱并从信箱中接收

### 同步问题

#### 阻塞

阻塞发送: 发送者发送后一直等待被接收;

阻塞接收: 接收者一直被阻塞直到接收到消息.

#### 非阻塞

发送者非阻塞: 发完消息后继续执行;

接收者非阻塞: 一直不停地接收消息, 即使收到空消息(null).

## 05 线程(Thread)

引入线程的目的: 简化线程间通信, 以小的开销提高进程内的并发程度.

线程作为 CPU 调度的基本单位, 而进程只作为其他资源分配单位.

线程同时拥有进程的所有资源.

**线程的优点**: 减小并发执行的时间和空间开销(线程的创建、退出和调度)，因此容许在系统中建立更多的线程来提高并发程度.

一个线程与它的对等线程共享:

- 代码段;
- 数据段;
- 操作系统资源.

### 用户线程和内核线程

**内核线程**(Kernel-Level Threads)
内核线程才是真正能 CPU 调度的基本单位, 用户线程不是.

时间片分配给线程.

**用户级线程**(User-Level Threads)
由用户级线程库进行管理的线程.

时间片分配给进程.

### 多线程模型

1. 多对一
   多个用户级线程映射到同一个内核级线程.
   **优点**: 线程管理是由用户空间的线程库来完成的，因此效率更高;
   **缺点**: 任一时刻只能有一个线程可以访问内核，并发度低;

2. 一对一
   每个用户级线程映射到一个内核级线程.
   **优点**: 提供了更好的并发性，一个用户线程发起系统调用时允许另一个线程运行;
   **缺点**: **开销大**，每创建一个用户线程需要创建一个相应的内核线程，带来了额外的开销，所以许多系统众限制应用中的线程数目.

3. 多对多
   不限制应用线程数、多个线程可以并发.
   
   多个用户级线程绑定到多个内核级线程;

## 06 进程调度

### 三级调度

- 作业调度(又称高级调度/长调度)
- 进程调度(又称低级调度/短调度)
- 中级调度

### 什么时候需要进程调度

- **运行转等待**
- _运行转就绪_
- _等待转就绪_
- **终止运行**

### 调度准则

**CPU 利用率**: 使 CPU 尽量忙碌;

**吞吐量**: 单位时间内运行完的进程数;

**周转时间**: 进程从提交到结束的全部时间;

**等待时间**: 进程在就绪队列中等待调度的时间片总和;

**响应时间**: 从进程提出请求到首次被响应的时间段[在分时系统环境下不是输出完结果的时间]

调度算法影响的是**等待时间**.

### 调度算法

- 先来先服务 FCFS
- 短调度有限 SJF
- 优先级调度 Priority Scheduling
  - 静态优先级: 导致饥饿
    通常系统进程的优先权高于一般用户进程的优先权。在用户进程中，**I/O 繁忙的进程应优先于 CPU 繁忙的进程**，以保证 CPU 和 I/O 设备之间的并行操作
  - 动态优先级:改变优先级的因素有：
    - 进程的等待时间
    - 已使用处理机的时间
    - 资源使用情况
  - 时间片轮转(Round Robin)
  - 多级队列 Multilevel Queue
  - 多级反馈队列 Multilevel Feedback Queue
    存在多个就绪队列, 每个队列优先级不同, 各自时间片轮转. 优先级越高的时间片越小.
  - 高响应比优先
    响应比$RP = 1 + \cfrac{已等待时间}{要求运行时间}$

## 08 死锁

### 8.1 死锁产生的四个条件

1. **互斥**: 一次只有一个进程可以使用某资源;
2. **占有并等待**: 一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源(请求与保持);
3. **不可抢占**: 一个资源只有当持有它的进程完成任务后才能自由释放(非剥夺);
4. **循环等待**: 等待资源的进程之间存在环.

### 8.2 处理死锁的方法

#### 8.2.1 忽略

鸵鸟策略, 假装死锁没有发生过.

#### 8.2.2 死锁预防

确保系统永远不会进入死锁状态 -> 破坏死锁的条件.

1. 破坏**占有并等待**
   - 一次性申请所有资源 
   - 效率低, 可能出现饥饿.
2. 破坏**不可抢占**
   - 如果进程的申请没有实现, 它要释放所有资源.
   - 抢占的资源放入进程等待列表中;
   - 只有进程能够重新得到就得资源和新申请的资源时, 才可以重新开始.
3. 破坏**循环等待**
   - 将所有资源放入资源列表中, 并要求进程按照资源列表申请资源.

#### 8.2.3 死锁避免

允许进程动态地申请资源，系统在进行资源分配之前，先计算资源分配的安全性。 若此次分配不会导致系统从安全状态向不安全状态转换，便可将资源分配给进程，否则不分配资源，进程必须阻塞等待.
